#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    limLift,         sensorAnalog)
#pragma config(Sensor, in6,    lsBarL,         sensorReflection)
#pragma config(Sensor, in7,    lsBarR,         sensorReflection)
#pragma config(Sensor, in8,    lsMobile,       sensorReflection)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  sonarL,         sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  limArm,         sensorTouch)
#pragma config(Sensor, dgtl10, jmpSkills,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, sonarR,         sensorSONAR_mm)
#pragma config(Motor,  port2,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftL,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define CHECK_POTI_JUMPS
#define LOGS 1
//#define MOTOR_SENSOR_LOGS

//#define FORCE_AUTO
//#define IGNORE_AUTO
//#define IGNORE_DISABLE

//#define SKILLS_CUTOFF 59500
//#define AUTO_CUTOFF 14500

// Programming skills selector
// Negative = run autoTest
// 0 - No programming skills
// 1 - Primary individual goal route (110 points)
// 2 - Secondary double goal route (? points)
#define SKILLS_ROUTE 0

#define DRIVE_WEIGHT_GAME 0
#define DRIVE_WEIGHT_SKILLS 0
#define TURN_WEIGHT_GAME 3
#define TURN_WEIGHT_SKILLS 7

// Necessary definitions

#define TID0(routine) #routine, 0
#define TID1(routine, id) #routine, id
#define TID2(routine, major, minor) #routine, ((major << 8) | minor)

// Year-independent libraries (headers)

#include "task.h"
#include "async.h"
#include "timeout.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"
#include "state.h"

// Timeout function

bool TimedOut(unsigned long timeOut, const unsigned char *routine, unsigned short id, bool kill = true, tTimeoutVelSourceType velSourceType = velNone, unsigned long velSourceData = 0, float vel = 0, unsigned long elpsdTime = 0, int* velSafetyCount = NULL);

// Year-independent libraries (source)

#include "task.c"
#include "async.c"
#include "timeout.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"
#include "state.c"

// Other includes

#include "Vex_Competition_Includes_Custom.c"

#include "controls.h"

#include "auto.h"
#include "auto_simple.h"
#include "auto_runs.h"
#include "custom_drive.h"
#include "custom_turning.h"
#include "diagnostics.h"

#define TRACK_IN_DRIVER

#define DATALOG_LIFT -1
#define DATALOG_ARM -1
#define DATALOG_TURN -1
#define DATALOG_TIMEOUT -1
#define DATALOG_SWEEP -1
#define DATALOG_BATTERY -1
#define DATALOG_TEST -1

bool stackRunning();

typedef enum _wallTurn {
	wtNone,
	wtLeft,
	wtRight
} tWallTurn;

bool gWallTurnCheck = false;
tWallTurn gWallTurn = wtNone;

typedef enum _stackFlags {
	sfNone = 0,
	sfStack = 1,
	sfDetach = 2,
	sfClear = 4,
	sfReturn = 8,
	sfMobile = 16,
	sfLoader = 32,
	sfNoResetArm = 64,
	sfNoResetLift = 128,
	sfRapid = 256,
	sfNoResetAuto = 512,
	sfPull = 1024
} tStackFlags;

typedef enum _stackStates {
	stackNotRunning,
	stackPickupGround,
	stackPickupLoader,
	stackStationaryPrep,
	stackStationary,
	stackStack,
	stackDetach,
	stackClear,
	stackReturn,
	stackWall,
	stackTip
} tStackStates;

DECLARE_MACHINE(stack, tStackStates)

#define STACK_CLEAR_CONFIG(flags, mobileState, mobileFlags) ((flags) | sfClear | sfMobile | ((mobileState) << 16) | ((mobileFlags) << 24))
#define STACK_RAPID_CONFIG(flags, maxCones) ((flags) | sfStack | sfRapid | ((maxCones) << 12))
#define MAX_STACK 12
#define MAX_STATIONARY 7

sCycleData gMainCycle;
int gNumCones = 0;

#define DRIVE_TURN_BRAKE 6

bool gDriveManual;
bool gWall;

bool isMobileSlow();

/* Drive */
void setDrive(word left, word right, bool debug = false)
{
	if (debug)
		if (LOGS) writeDebugStreamLine("DRIVE %d %d", left, right);
	gMotor[driveL1].power = gMotor[driveL2].power = left;
	gMotor[driveR1].power = gMotor[driveR2].power = right;
}

void handleDrive()
{
	if (gDriveManual)
	{
		short y = lookupDrive(gJoy[JOY_THROTTLE].cur);
		short a = abs(y)<gTurnCurveLim? lookupTurn(gJoy[JOY_TURN].cur): gJoy[JOY_TURN].cur;

#if defined(DRIVE_TURN_BRAKE) && DRIVE_TURN_BRAKE > 0
#ifndef TRACK_IN_DRIVER
#error "Turn braking requires track in driver!"
#endif
		if (!a && abs(gVelocity.a) > 0.5)
			a = -DRIVE_TURN_BRAKE * sgn(gVelocity.a);
#endif

		word l = y + a;
		word r = y - a;
		setDrive(l, r);
	}
}


/* Lift */
typedef enum _tLiftStates {
	liftManaged,
	liftIdle,
	liftManual,
	liftRaiseSimpleState,
	liftLowerSimpleState,
	liftToBottom,
	liftToTarget,
	liftHold,
	liftHoldDown,
	liftHoldUp,
} tLiftStates;

void setLift(word power,bool debug=false)
{
	if( debug ) if (LOGS) writeDebugStreamLine("%06d Lift %4d", nPgmTime,power );
	gMotor[liftL].power = gMotor[liftR].power = power;
}
//real lift bottom = 770
#define LIFT_BOTTOM 800 //1100
#define LIFT_TOP (LIFT_BOTTOM + 1930)
#define LIFT_MID (LIFT_BOTTOM + 620)
#define LIFT_HOLD_DOWN_THRESHOLD (LIFT_BOTTOM + 50)
#define LIFT_HOLD_UP_THRESHOLD (LIFT_TOP - 100)
#define LIFT_LOADER (LIFT_BOTTOM + 800)
#define LIFT_LOADER_PICKUP (LIFT_BOTTOM + 480)
#define LIFT_RETURN (LIFT_BOTTOM + 400)
#define LIFT_WALL (LIFT_BOTTOM + 450)

DECLARE_MACHINE(lift, tLiftStates)

void liftRaiseSimple(int target, word mainPower, word brakePower)
{
	if (LOGS) writeDebugStreamLine("Raising lift to %d", target);
	setLift(mainPower);
	int pos;
	while ((pos = gSensor[liftPoti].value) < target) sleep(10);
	if (brakePower)
	{
		setLift(brakePower);
		sleep(200);
	}
	if (LOGS) writeDebugStreamLine("Lift moved up to %d | %d", target, pos);
}

NEW_ASYNC_VOID_STATE_3(lift, liftRaiseSimpleState, liftRaiseSimple, int, word, word);

void liftLowerSimple(int target, word mainPower, word brakePower)
{
	if (LOGS) writeDebugStreamLine("Lowering lift to %d", target);
	setLift(mainPower);
	int pos;
	while ((pos = gSensor[liftPoti].value) > target) sleep(10);
	if (brakePower)
	{
		setLift(brakePower);
		sleep(200);
	}
	if (LOGS) writeDebugStreamLine("Lift moved down to %d | %d", target, pos);
}

NEW_ASYNC_VOID_STATE_3(lift, liftLowerSimpleState, liftLowerSimple, int, word, word);

MAKE_MACHINE(lift, tLiftStates, liftIdle,
{
case liftIdle:
	setLift(0);
	break;
case liftRaiseSimpleState:
	{
		STATE_INVOKE_ASYNC(liftRaiseSimple);
		NEXT_STATE(liftHold);
	}
case liftLowerSimpleState:
	{
		STATE_INVOKE_ASYNC(liftLowerSimple);
		NEXT_STATE(liftHold);
	}
case liftToBottom:
	{
		word power = arg ? -abs(arg) : -127;
		setLift(power);
		while (!gSensor[limLift].value) sleep(10);
		NEXT_STATE(liftHoldDown);
	}
case liftToTarget:
	{
		int target = arg;
		int err;
		if (LOGS) writeDebugStreamLine("%d Moving lift to %d", nPgmTime, target);
		velocityClear(liftPoti);
		do
		{
			err = target - gSensor[liftPoti].value;
			float vTarget = sgn(err) * 4.0 * (1.0 - exp(-0.0025 * abs(err)));
			const float bias = 8;
			const float kB = 17.0;
			const float kP = 10.0;
			velocityCheck(liftPoti);
			tHog();
			if (DATALOG_LIFT != -1)
			{
				datalogDataGroupStart();
				datalogAddValue(DATALOG_LIFT + 0, err);
				datalogAddValue(DATALOG_LIFT + 1, vTarget * 1000);
			}
			if (gSensor[liftPoti].velGood)
			{
				float power = kB * vTarget + kP * (vTarget - gSensor[liftPoti].velocity) + bias;

				if (power * sgn(err) < 25 && gSensor[liftPoti].velocity * sgn(err) < abs(vTarget))
					power = 25 * sgn(err);
				else if (sgn(power) == -sgn(vTarget))
					LIM_TO_VAL_SET(power, 7);
				else if (sgn(power) == -sgn(gSensor[liftPoti].velocity))
					LIM_TO_VAL_SET(power, 25);
				else
					LIM_TO_VAL_SET(power, 127);
				setLift((word) power);
				if (DATALOG_LIFT != -1)
				{
					datalogAddValue(DATALOG_LIFT + 2, gSensor[liftPoti].velocity * 1000);
					datalogAddValue(DATALOG_LIFT + 3, power * 10);
				}
			}
			if (DATALOG_LIFT != -1)
				datalogDataGroupEnd();
			tRelease();
			sleep(20);
		} while (abs(err) > 100);
		if (LOGS) writeDebugStreamLine("%d Stopping lift", nPgmTime);
		if (gSensor[liftPoti].velGood)
		{
			setLift(sgn(gSensor[liftPoti].velocity) > 0 ? -15 : 10);
			sleep(150);
			setLift(0);
		}
		if (LOGS) writeDebugStreamLine("%d Moved lift to %d | %d", nPgmTime, target, gSensor[liftPoti].value);
		NEXT_STATE(liftHold);
	}
case liftHold:
	{
		int target = gSensor[liftPoti].value;
		if (target < LIFT_HOLD_DOWN_THRESHOLD)
			NEXT_STATE(liftHoldDown);
		if (target > LIFT_HOLD_UP_THRESHOLD)
			NEXT_STATE(liftHoldUp);
		while (true)
		{
			setLift(gSensor[liftPoti].value > LIFT_MID ? 12 : 10);
			sleep(40);
		}
		break;
	}
case liftHoldDown:
	while (true)
	{
		setLift(gSensor[limLift].value ? -15 : -90);
		sleep(40);
	}
	break;
case liftHoldUp:
	while (true)
	{
		setLift(gSensor[liftPoti].value >= LIFT_TOP ? 15 : 127);
		sleep(40);
	}
	break;
})

void handleLift()
{
	if (gSensor[limLift].value && !gSensor[limLift].lstValue)
		if (LOGS) writeDebugStreamLine("%d LIFT LIMIT RISING", nPgmTime);
	if (!gSensor[limLift].value && gSensor[limLift].lstValue)
		if (LOGS) writeDebugStreamLine("%d LIFT LIMIT FALLING", nPgmTime);

	if (liftState == liftManaged || stackRunning()) return;

	if (RISING(JOY_LIFT_DRIVER) || RISING(JOY_LIFT_PARTNER))
	{
		liftSet(liftManual);
	}
	if (liftState == liftManual && !gJoy[JOY_LIFT_DRIVER].cur && !gJoy[JOY_LIFT_PARTNER].cur)
	{
		liftSet(liftHold, -1);
	}

	if (liftState == liftManual)
	{
		word value = gJoy[JOY_LIFT_DRIVER].cur ? gJoy[JOY_LIFT_DRIVER].cur : gJoy[JOY_LIFT_PARTNER].cur;
		value = value * 2 - 128 * sgn(value);
		if (gSensor[liftPoti].value <= LIFT_BOTTOM && value < -15) value = -15;
		if (gSensor[liftPoti].value >= LIFT_TOP && value > 15) value = 15;
		setLift(value);
	}
}


/* Arm */
typedef enum _tArmStates {
	armManaged,
	armIdle,
	armManual,
	armToTarget,
	armRaiseSimpleState,
	armLowerSimpleState,
	armToBottom,
	armStopping,
	armHold,
	armHoldDown,
	armHoldMobile
} tArmStates;

#define RL_ARM_TOP 2700
#define ARM_TOP (RL_ARM_TOP - 100)

//Actual ARM_BOTTOM = 1020
#define ARM_BOTTOM (RL_ARM_TOP - 1530)

#define ARM_PRESTACK (RL_ARM_TOP - 800)
#define ARM_RELEASE (RL_ARM_TOP - 700)
#define ARM_CARRY (RL_ARM_TOP - 1040)
#define ARM_STACK (RL_ARM_TOP - 100)
#define ARM_HORIZONTAL (RL_ARM_TOP - 1590)
#define ARM_HOLD_DOWN_THRESHOLD (RL_ARM_TOP - 1550)

tArmStates gArmSimpleNextState = armIdle;

void setArm(word power, bool debug = false)
{
	if( debug ) if (LOGS) writeDebugStreamLine("%06d Arm  %4d", nPgmTime, power);
	gMotor[arm].power = power;
}

DECLARE_MACHINE(arm, tArmStates)

void armRaiseSimple(int target, word mainPower, word brakePower, float earlyDrop, unsigned long brakeDelay, tArmStates next)
{
	setArm(mainPower);
	int pos;
	velocityClear(armPoti);
	do
	{
		sleep(10);
		pos = gSensor[armPoti].value;
		velocityCheck(armPoti);
		if (gSensor[armPoti].velGood && pos + gSensor[armPoti].velocity * earlyDrop > target)
			break;
	}	while (pos < target);
	if (brakePower)
	{
		setArm(brakePower);
		sleep(brakeDelay);
		setArm(0);
	}
	if (LOGS) writeDebugStreamLine("Arm moved up to %d | %d", target, pos);
	gArmSimpleNextState = next;
}

NEW_ASYNC_VOID_STATE_6(arm, armRaiseSimpleState, armRaiseSimple, int, word, word, float, unsigned long, tArmStates);

unsigned long armRaiseSimpleAsync(int target, word mainPower, word brakePower)
{
	return armRaiseSimpleAsync(target, mainPower, brakePower, 0, 200, armHold);
}

void armLowerSimple(int target, word mainPower, word brakePower, float earlyDrop, unsigned long brakeDelay, tArmStates next)
{
	setArm(mainPower);
	int pos;
	velocityClear(armPoti);
	do
	{
		sleep(10);
		pos = gSensor[armPoti].value;
		velocityCheck(armPoti);
		if (gSensor[armPoti].velGood && pos + gSensor[armPoti].velocity * earlyDrop < target)
			break;
	} while (pos > target);
	if (brakePower)
	{
		setArm(brakePower);
		sleep(brakeDelay);
	}
	if (LOGS) writeDebugStreamLine("Arm moved down to %d | %d", target, pos);
	gArmSimpleNextState = next;
}

NEW_ASYNC_VOID_STATE_6(arm, armLowerSimpleState, armLowerSimple, int, word, word, float, unsigned long, tArmStates);

unsigned long armLowerSimpleAsync(int target, word mainPower, word brakePower)
{
	return armLowerSimpleAsync(target, mainPower, brakePower, 0, 200, armHold);
}

MAKE_MACHINE(arm, tArmStates, armIdle,
{
case armIdle:
	setArm(0);
	break;
case armToTarget:
	{
		int target = arg;
		int err;
		if (LOGS) writeDebugStreamLine("%d Moving arm to %d", nPgmTime, target);
		velocityClear(armPoti);
		do
		{
			err = target - gSensor[armPoti].value;
			float vTarget = sgn(err) * 5.5 * (1.0 - exp(-0.0005 * abs(err)));
			const float bias = 3;
			const float kB = 30.0;
			const float kP = 8.0;
			velocityCheck(armPoti);
			tHog();
			if (DATALOG_ARM != -1)
			{
				datalogDataGroupStart();
				datalogAddValue(DATALOG_ARM + 0, err);
				datalogAddValue(DATALOG_ARM + 1, vTarget * 1000);
			}
			if (gSensor[armPoti].velGood)
			{
				float power = kB * vTarget + kP * (vTarget - gSensor[armPoti].velocity) + bias;

				if (power * sgn(err) < 20 && gSensor[armPoti].velocity * sgn(err) < abs(vTarget))
					power = 20 * sgn(err);
				else if (sgn(power) == -sgn(gSensor[armPoti].velocity))
					LIM_TO_VAL_SET(power, 20);
				else
					LIM_TO_VAL_SET(power, 127);
				setArm((word) power);
				if (DATALOG_ARM != -1)
				{
					datalogAddValue(DATALOG_ARM + 2, gSensor[armPoti].velocity * 1000);
					datalogAddValue(DATALOG_ARM + 3, power * 10);
				}
			}
			if (DATALOG_ARM != -1)
				datalogDataGroupEnd();
			tRelease();
			sleep(20);
		} while (abs(err) > 100);
		if (LOGS) writeDebugStreamLine("%d Stopping arm", nPgmTime);
		if (gSensor[armPoti].velGood)
		{
			setArm(sgn(gSensor[armPoti].velocity) > 0 ? -10 : 20);
			sleep(150);
			setArm(0);
		}
		if (LOGS) writeDebugStreamLine("%d Moved arm to %d | %d", nPgmTime, target, gSensor[armPoti].value);
		NEXT_STATE(armHold);
	}
case armRaiseSimpleState:
	{
		STATE_INVOKE_ASYNC(armRaiseSimple);
		NEXT_STATE(gArmSimpleNextState);
	}
case armLowerSimpleState:
	{
		STATE_INVOKE_ASYNC(armLowerSimple);
		NEXT_STATE(gArmSimpleNextState);
	}
case armToBottom:
	{
		word power = arg ? -abs(arg) : -127;
		setArm(power);
		while (!gSensor[limArm].value) sleep(10);
		NEXT_STATE(armHoldDown);
	}
case armStopping:
	velocityClear(armPoti);
	do
	{
		sleep(5);
		velocityCheck(armPoti);
	} while (!gSensor[armPoti].velGood);
	setArm(sgn(gSensor[armPoti].velocity) * -25);
	sleep(150);
	NEXT_STATE(armHold);
case armHold:
	{
		if (gSensor[armPoti].value < ARM_HOLD_DOWN_THRESHOLD)
			NEXT_STATE(armHoldDown)
		setArm(7);
		break;
	}
case armHoldDown:
	while (true)
	{
		setArm(gSensor[limArm].value ? -15 : -40);
		sleep(40);
	}
	break;
case armHoldMobile:
	setArm(-15);
	break;
})

void handleArm()
{
	if (gSensor[limArm].value && !gSensor[limArm].lstValue)
		if (LOGS) writeDebugStreamLine("%d ARM LIMIT RISING", nPgmTime);
	if (!gSensor[limArm].value && gSensor[limArm].lstValue)
		if (LOGS) writeDebugStreamLine("%d ARM LIMIT FALLING", nPgmTime);

	if (armState == armManaged || stackRunning()) return;

	if (RISING(JOY_ARM_DRIVER) || RISING(JOY_ARM_PARTNER))
	{
		armSet(armManual);
	}
	if (armState == armManual && !gJoy[JOY_ARM_DRIVER].cur && !gJoy[JOY_ARM_PARTNER].cur)
	{
		armSet(armHold, -1);
	}

	if (armState == armManual)
	{
		word value = gJoy[JOY_ARM_DRIVER].cur ? gJoy[JOY_ARM_DRIVER].cur : gJoy[JOY_ARM_PARTNER].cur;
		value = value * 2 - 128 * sgn(value);
		if (gSensor[armPoti].value >= ARM_TOP && value > 10) value = 10;
		if (gSensor[armPoti].value <= ARM_BOTTOM && value < -10) value = -10;
		setArm(value);
	}
}


/* Mobile */

typedef enum _tMobileFlags {
	mfNone = 0,
	mfClear = 1
} tMobileFlags;

typedef enum _tMobileStates {
	mobileManaged,
	mobileIdle,
	mobileTop,
	mobileBottom,
	mobileBottomSlow,
	mobileUpToMiddle,
	mobileDownToMiddle,
	mobileMiddle
} tMobileStates;

#define MOBILE_TOP 2550
#define MOBILE_BOTTOM 950
#define MOBILE_MIDDLE_UP 1150
#define MOBILE_MIDDLE_DOWN 1550
#define MOBILE_MIDDLE_THRESHOLD 2250
#define MOBILE_HALFWAY 1550

#define MOBILE_UP_POWER 127
#define MOBILE_DOWN_POWER -127
#define MOBILE_UP_HOLD_POWER 12
#define MOBILE_DOWN_HOLD_POWER -15
#define MOBILE_DOWN_SLOW_POWER_1 -60
#define MOBILE_DOWN_SLOW_POWER_2 6

#define MOBILE_LIFT_CHECK_THRESHOLD 1900
#define LIFT_MOBILE_THRESHOLD (LIFT_BOTTOM + 200)

#define MOBILE_SLOW_HOLD_TIMEOUT 500
#define MOBILE_AUTO_TIMEOUT 500

// NUMBER OF CONES         0   1   2   3   4   5   6   7   8   9   10  11  12
int gMobileSlowPeak[13] = {60, 60, 60, 60, 60, 60, 60, 60, 70, 70, 70, 70, 70};
int gMobileSlowDown[13] = {0,  0,  0,  5,  7,  7,  7,  7,  8,  8,  8,  8,  8};

bool gMobileCheckLift;
bool gMobileSlow = false;
bool gMobileAutoEnabled = true;
unsigned long gMobileAutoTimeout = 0;
unsigned long gMobileAutoIgnore = 0;

void setMobile(word power, bool debug = false)
{
	gMotor[mobile].power = power;
}

void mobileClearLift()
{
	if (LOGS) writeDebugStreamLine("mobileClearLift");
	if (gMobileCheckLift && gSensor[liftPoti].value < LIFT_MOBILE_THRESHOLD)
	{
		liftRaiseSimpleAsync(LIFT_MOBILE_THRESHOLD, 127, -15);
		unsigned long timeout = nPgmTime + 1000;
		liftTimeoutWhile(liftRaiseSimpleState, timeout, TID0(mobileClearLift));
	}
}

DECLARE_MACHINE(mobile, tMobileStates)

MAKE_MACHINE(mobile, tMobileStates, mobileIdle,
{
case mobileIdle:
	setMobile(0);
	break;
case mobileTop:
	{
		gMobileAutoEnabled = false;
		if (arg & mfClear)
			mobileClearLift();
		setMobile(MOBILE_UP_POWER);
		unsigned long timeout = nPgmTime + 1100;

		while (gSensor[mobilePoti].value < MOBILE_TOP - 600 && !TimedOut(timeout, TID1(mobileTop, 1), false)) sleep(10);
		//Coast if timedout
		if ( TimedOut(timeout, TID1(mobileTop, 2), false) )
			NEXT_STATE(mobileIdle)
		else
			setMobile(MOBILE_UP_HOLD_POWER);
		break;
	}
case mobileBottom:
	{
		gNumCones = 0;
		gMobileAutoIgnore = nPgmTime + 1500;
		if (gMobileSlow)
			NEXT_STATE(mobileBottomSlow)
		if ((arg & mfClear) && gSensor[mobilePoti].value > MOBILE_LIFT_CHECK_THRESHOLD)
			mobileClearLift();
		if (LOGS) writeDebugStreamLine("mobileBottom %d", gNumCones);
		setMobile(MOBILE_DOWN_POWER);
		unsigned long timeout = nPgmTime + 1100;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_BOTTOM, timeout, TID0(mobileBottom), false);
		//Coast if timedout
		if ( TimedOut(timeout, TID0(mobileBottom), false) )
			NEXT_STATE(mobileIdle)
		else
			setMobile(MOBILE_DOWN_HOLD_POWER);
		break;
	}
case mobileBottomSlow:
	{
		gMobileSlow = false;
		if ((arg & mfClear) && gSensor[mobilePoti].value > MOBILE_LIFT_CHECK_THRESHOLD)
			mobileClearLift();
		if (LOGS) writeDebugStreamLine("mobileBottomSlow %d", gNumCones);
		setMobile(-127);
		unsigned long timeout = nPgmTime + 500;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_TOP - 200, timeout, TID1(mobileBottomSlow, 1));
		//setMobile(-gMobileSlowPeak[gNumCones]);
		timeout = nPgmTime + 3500;
		//timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_HALFWAY + 200, timeout, TID1(mobileBottomSlow, 2));
		velocityClear(mobilePoti);
		while (gSensor[mobilePoti].value > MOBILE_HALFWAY + 200 && !TimedOut(timeout, TID1(mobileBottomSlow, 2), true, VEL_NONE, 0, 0, NULL))
		{
			velocityCheck(mobilePoti);
			setMobile(gSensor[mobilePoti].velGood && gSensor[mobilePoti].velocity > -0.5 ? -70 : -gMobileSlowPeak[gNumCones]);
			sleep(10);
		}
		setMobile(gMobileSlowDown[gNumCones]);
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_BOTTOM + 200, timeout, TID1(mobileBottomSlow, 3));
		setMobile(0);
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_BOTTOM, timeout, TID1(mobileBottomSlow, 4));
		arg = mfNone;
		NEXT_STATE(mobileBottom)
	}
case mobileUpToMiddle:
	{
		setMobile(MOBILE_UP_POWER);
		unsigned long timeout = nPgmTime + 1000;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_MIDDLE_UP, timeout, TID0(mobileUpToMiddle));
		setMobile(15);
		NEXT_STATE(mobileMiddle)
	}
case mobileDownToMiddle:
	{
		if (arg & mfClear)
			mobileClearLift();
		setMobile(MOBILE_DOWN_POWER);
		unsigned long timeout = nPgmTime + 1000;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_MIDDLE_DOWN, timeout, TID0(mobileUpToMiddle));
		setMobile(15);
		NEXT_STATE(mobileMiddle)
	}
case mobileMiddle:
	while (gSensor[mobilePoti].value < MOBILE_MIDDLE_THRESHOLD) sleep(10);
	arg = mfClear;
	NEXT_STATE(mobileTop)
})

void mobileWaitForSlowHold(TVexJoysticks btn)
{
	unsigned long timeout = nPgmTime + MOBILE_SLOW_HOLD_TIMEOUT;
	while (nPgmTime < timeout)
	{
		if (!gJoy[btn].cur) return;
		sleep(10);
	}
	gMobileSlow = true;
	if (mobileState == mobileBottom)
		mobileSet(mobileBottomSlow);
	if (LOGS) writeDebugStreamLine("mobileBottomSlow activated");
}

NEW_ASYNC_VOID_1(mobileWaitForSlowHold, TVexJoysticks);

void handleMobile()
{
	if (mobileState == mobileManaged || nPgmTime < gMobileAutoTimeout)
		return;

	if (mobileState == mobileUpToMiddle || mobileState == mobileDownToMiddle || mobileState == mobileMiddle)
	{
		if (RISING(BTN_MOBILE_MIDDLE))
			mobileSet(mobileTop, mfClear);
		if (RISING(BTN_MOBILE_TOGGLE) && !gWallTurnCheck)
		{
			gMobileSlow = false;
			stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNone, mobileBottom, mfClear));
			mobileWaitForSlowHoldAsync(BTN_MOBILE_MIDDLE);
		}
	}
	else
	{
		if (RISING(BTN_MOBILE_TOGGLE) && !gWallTurnCheck)
		{
			if (gSensor[mobilePoti].value > MOBILE_HALFWAY)
			{
				if (gNumCones > (gSensor[jmpSkills].value ? 4 : 2))
					stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNone, mobileBottomSlow, mfClear));
				else
				{
					gMobileSlow = false;
					stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNone, mobileBottom, mfClear));
					mobileWaitForSlowHoldAsync(BTN_MOBILE_TOGGLE);
				}
			}
			else
				mobileSet(mobileTop, mfClear);
		}
		if (RISING(BTN_MOBILE_MIDDLE))
		{
			if (gSensor[mobilePoti].value > MOBILE_HALFWAY)
			{
				stackSet(stackDetach, STACK_CLEAR_CONFIG(sfNone, mobileDownToMiddle, mfClear));
			}
			else
				mobileSet(mobileUpToMiddle, mfClear);
		}
	}
}

bool isMobileSlow()
{
	return mobileState == mobileBottomSlow;
}


/* Macros + Autonomous */

// STACKING ON                     0     1     2     3     4     5     6     7     8     9     10    11
const int gLiftRaiseTarget[12] = { 1000, 1100, 1200, 1300, 1400, 1600, 1650, 1900, 2100, 2300, 2650, LIFT_TOP};
const int gLiftPlaceTarget[12] = { 850,  850,  900,  1010, 1150, 1250, 1440, 1500, 1600, 1750, 1950, 1950 };
const int gLiftRaiseTargetS[7] = { 1850, 1920, 2020, 2120, 2240, 2380, LIFT_TOP };
const int gLiftPlaceTargetS[7] = { 1560, 1660, 1750, 1860, 1960, 2100, 2220 };

bool gStack = false;
bool gLoader = false;
bool gTurned = false;

unsigned long gPrepStart = 0;
unsigned long gSkillsSpinTimeout = 0;

#define RAPID (gStack || ((arg & sfRapid) && gNumCones < ((arg >> 12) & 0xF)))

MAKE_MACHINE(stack, tStackStates, stackNotRunning,
{
case stackNotRunning:
	if (LOGS) writeDebugStreamLine("%06d stackNotRunning %x %d", npgmTime, arg, gNumCones);
	gWallTurnCheck = false;
	if (!(arg & sfNoResetLift))
		liftSet(liftHold);
	if (!(arg & sfNoResetArm))
		armSet(armHold);
	if (!(arg & sfNoResetAuto))
	{
		autoSimpleReset();
		setDrive(0, 0);
	}
	gDriveManual = true;
	gWallTurn = wtNone;
	break;
case stackPickupGround:
	{
		if (LOGS) writeDebugStreamLine("%06d stackPickupGround %x %d", nPgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;
		unsigned long driveTimeout;

		if (arg & sfPull)
		{
			gDriveManual = false;
			//gWallTurnCheck = true;
			driveTimeout = nPgmTime + 2000;
			moveToTargetDisSimpleAsync(gPosition.a, -1.5, gPosition.y, gPosition.x, -60, 0, 0, 0, 0, 0, stopHarsh, mttSimple, false);
			autoSimpleTimeoutWhile(moveToTargetDisSimpleState, driveTimeout, TID1(stackWall, 3));
			gDriveManual = true;

			liftTimeOut = nPgmTime + 2000;
			liftSet(liftToTarget, LIFT_WALL-200);
			//liftRaiseSimpleAsync(LIFT_WALL-100, 70, -20);
			armSet(armToBottom, -127);
			liftTimeoutWhile(liftToTarget, liftTimeOut, TID1(stackWall, 4));
		}
		else if (gSensor[liftPoti].value < LIFT_BOTTOM + 400 && gSensor[armPoti].value > ARM_HORIZONTAL)
		{
			armSet(armToTarget, ARM_RELEASE);
		}
		else
		{
			armSet(armToBottom, -127);
		}
		if (LOGS) writeDebugStreamLine("stackPickupGround 1 %06d %d", nPgmTime, gSensor[armPoti].value);

		liftSet(liftToBottom, -127);
		liftTimeOut = nPgmTime + 1200;
		liftTimeoutWhile(liftToBottom, liftTimeOut, TID1(stackPickupGround, 2));

		if (LOGS) writeDebugStreamLine("stackPickupGround 2 %06d %d", nPgmTime, gSensor[liftPoti].value);

		armSet(armToBottom, -127);
		armTimeOut = nPgmTime + 1500;
		liftSet(liftHoldDown);
		if (arg & sfPull)
		{
			timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[armPoti].value, ARM_PRESTACK - 500, armTimeOut, TID1(stackPickupGround, 3));
		}
		timeoutWhileFalse((bool *)&gSensor[limArm].value, armTimeOut, TID1(stackPickupGround, 5));

		if (LOGS) writeDebugStreamLine("stackPickupGround 3 %06d %d", nPgmTime, gSensor[armPoti].value);

		sleep((arg & sfPull) ? 150 : 50);
		armSet(armManaged);
		setArm(127);
		armTimeOut = nPgmTime + 500;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[armPoti].value, ARM_HORIZONTAL, armTimeOut, TID1(stackPickupGround, 6));
		armSet(armToTarget, ARM_PRESTACK - 500);

		gWallTurnCheck = false;
		gDriveManual = true;

		if (arg & sfPull && gNumCones <= 5 && gWallTurn != wtNone)
		{
			gDriveManual = false;
			moveToTargetDisSimpleAsync(gPosition.a + (gWallTurn == wtLeft ? -0.5 * PI : 0.5 * PI), 12, gPosition.y, gPosition.x, -127, 0, 2, 0, 0, 0, stopSoft, mttSimple, false);
		}

		NEXT_STATE((arg & sfStack) ? stackStack : stackNotRunning)
	}
case stackPickupLoader:
	{
		if (LOGS) writeDebugStreamLine("%06d stackPickupLoader %x %d", nPgmTime, arg, gNumCones);
		if (gNumCones >= MAX_STACK)
			NEXT_STATE(stackNotRunning)

		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		armSet(armToBottom, -127);
		armTimeOut = nPgmTime + 1500;
		bool earlyLift;
		if (earlyLift = gSensor[liftPoti].value > LIFT_LOADER + 200)
		{
			liftLowerSimpleAsync(LIFT_LOADER_PICKUP, -127, 0);
			liftTimeOut = nPgmTime + 600;
		}
		timeoutWhileFalse((bool *) &gSensor[limArm].value, armTimeOut, TID1(stackPickupLoader, 2));
		if (!earlyLift)
		{
			liftLowerSimpleAsync(LIFT_LOADER_PICKUP, -127, 0);
			liftTimeOut = nPgmTime + 600;
		}
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[liftPoti].value, LIFT_LOADER_PICKUP, liftTimeOut, TID1(stackPickupLoader, 3));
		liftSet(liftManaged);
		setLift(-15);
		sleep(100);
		liftSet(liftHold);

		NEXT_STATE((arg & sfStack) ? stackStack : stackNotRunning)
	}
case stackStationaryPrep:
	{
		if (LOGS) writeDebugStreamLine("%06d stackStationaryPrep %x %d", nPgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		if (gNumCones >= MAX_STATIONARY)
			NEXT_STATE(stackNotRunning)

		armRaiseSimpleAsync(ARM_TOP, 127, 0);
		armTimeOut = nPgmTime + 1500;
		liftRaiseSimpleAsync(gLiftRaiseTargetS[gNumCones], 127, (gNumCones == MAX_STATIONARY - 1) ? 0 : -10);
		liftTimeOut = nPgmTime + 1500;
		armTimeoutUntil(armHold, armTimeOut, TID1(stackStationaryPrep, 1));
		liftTimeoutWhile(liftRaiseSimpleState, liftTimeOut, TID1(stackStationaryPrep, 1));
		NEXT_STATE(stackNotRunning)
	}
case stackStationary:
	{
		if (LOGS) writeDebugStreamLine("%06d stackStationary %x %d", nPgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		if (gNumCones >= MAX_STATIONARY)
			NEXT_STATE(stackNotRunning)

		armRaiseSimpleAsync(ARM_TOP, 127, 0);
		armTimeOut = nPgmTime + 1000;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[armPoti].value, ARM_TOP - 100, armTimeOut, TID1(stackStationary, 1));
		armSet(armManaged);
		setArm(-20);
		liftLowerSimpleAsync(gLiftPlaceTargetS[gNumCones], -127, 25);
		liftTimeOut = nPgmTime + 2000;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[liftPoti].value, gLiftPlaceTargetS[gNumCones], liftTimeOut, TID1(stackStationary, 2));
		armLowerSimpleAsync(ARM_HORIZONTAL, -127, 25, 35, 200, armHold);
		armTimeOut = nPgmTime + 1500;
		timeoutWhileGreaterThanL(VEL_NONE, 0, &gSensor[armPoti].value, ARM_HORIZONTAL + 300, armTimeOut, TID1(stackStationary, 3));

		++gNumCones;

		long target = (gNumCones >= 5) ? LIFT_TOP : gLiftRaiseTargetS[gNumCones];
		liftRaiseSimpleAsync(target, 127, (gNumCones >= 4) ? 0 : -15);
		liftTimeOut = nPgmTime + 2000;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[liftPoti].value, target, liftTimeOut, TID1(stackStationary, 4));

		gDriveManual = true;

		armRaiseSimpleAsync(ARM_TOP, 127, -15);
		armTimeOut = nPgmTime + 2000;
		armTimeoutWhile(armRaiseSimpleState, armTimeOut, TID1(stackStationary, 5));
		liftTimeoutWhile(liftRaiseSimpleState, liftTimeOut, TID1(stackStationary, 6));

		NEXT_STATE(stackNotRunning)
	}
case stackStack:
	{
		if (LOGS) writeDebugStreamLine("%06d stackStack %x %d", nPgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		if (gNumCones >= MAX_STACK)
			NEXT_STATE(stackNotRunning)

		liftRaiseSimpleAsync(gLiftRaiseTarget[gNumCones], 127, (gNumCones < MAX_STACK - 1) ? -25 : 0);
		liftTimeOut = nPgmTime + 1500;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[liftPoti].value, gLiftRaiseTarget[gNumCones] - 400, liftTimeOut, TID1(stackStack, 1));

		armRaiseSimpleAsync(ARM_STACK, 127, 0);
		armTimeOut = nPgmTime + 1000;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[liftPoti].value, gLiftRaiseTarget[gNumCones] - 100, liftTimeOut, TID1(stackStack, 2));
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[armPoti].value, ARM_STACK - 100, armTimeOut, TID1(stackStack, 3));

		if ((arg & sfLoader) && (gNumCones == 5 || gNumCones == 6 || gNumCones == 7))
			liftLowerSimpleAsync(gLiftPlaceTarget[gNumCones], -60, 20);
		else
			liftLowerSimpleAsync(gLiftPlaceTarget[gNumCones], -70, 0);
		liftTimeOut = nPgmTime + 800;
		liftTimeoutWhile(liftLowerSimpleState, liftTimeOut, TID1(stackStack, 4));

		++gNumCones;

		NEXT_STATE((arg & (sfDetach | sfClear | sfReturn | sfRapid)) ? stackDetach : stackNotRunning)
	}
case stackDetach:
	if (LOGS) writeDebugStreamLine("%06d stackDetach %x %d", nPgmTime, arg, gNumCones);
	if (gNumCones > 0 && gSensor[liftPoti].value < gLiftRaiseTarget[MIN(gNumCones, MAX_STACK - 1)])
	{
		if (arg & sfLoader) {
			if (gNumCones > 7)
				liftLowerSimpleAsync(RAPID ? LIFT_LOADER_PICKUP : LIFT_LOADER, -50, 10);
			else
				liftSet(liftHold);
		}
		else if ((arg & sfReturn) && gNumCones > 3) {
			liftLowerSimpleAsync((arg & sfLoader) ? MAX(MIN(RAPID ? LIFT_LOADER_PICKUP : LIFT_LOADER, gLiftPlaceTarget[MAX(0, gNumCones - 1)]), gNumCones > 5 ? LIFT_LOADER : LIFT_LOADER_PICKUP) + 200 : RAPID ? LIFT_BOTTOM : 1650, -80, (arg & sfLoader) || !RAPID ? 20 : 0);
		}
		else {
			liftSet(liftManaged);
			setLift(-20);
		}
		tArmStates state = armLowerSimpleState;
		if ((arg & sfLoader) && (gNumCones == 5 || gNumCones == 6))
			armLowerSimpleAsync(ARM_RELEASE, -127, 0);
		else if (RAPID)
		{
			state = armToBottom;
			armSet(armToBottom, -127);
		}
		else if (gNumCones < ((arg & sfLoader) ? 7 : 3))
			armLowerSimpleAsync((gNumCones == 3 && !(arg & sfLoader)) ? ARM_RELEASE - 100 : ARM_RELEASE, -127, 45, 100, 80, armIdle);
		else
			armLowerSimpleAsync(ARM_RELEASE, -127, 0);
		unsigned long armTimeOut = nPgmTime + 800;
		armTimeoutWhile(state, armTimeOut, TID0(stackDetach));
		if ((arg & sfLoader) && RAPID)
			liftRaiseSimpleAsync(LIFT_LOADER, 80, -10);
		if (!(arg & sfLoader))
			armReset();
		if (arg & sfLoader)
			liftSet(liftHold);
		else
			liftReset();
	}
	if (RAPID) {
		arg |= sfStack;
		bool _gStack = gStack;
		gStack = false;
		if (gNumCones < MAX_STACK) {
			if (gNumCones == MAX_STACK - 1) {
				arg &= ~sfReturn;
				arg |= sfDetach;
			}
			if (gLoader) {
				if (gNumCones > 5) {
					arg |= sfLoader;
					gLoader = false;
					NEXT_STATE(stackPickupLoader)
				}
				gStack = _gStack;
			}
			else {
				arg &= ~sfLoader;
				NEXT_STATE(stackPickupGround)
			}
		}
	}
	NEXT_STATE((arg & sfClear) ? stackClear : (arg & sfReturn) ? stackReturn : stackNotRunning)
case stackClear:
	{
		if (LOGS) writeDebugStreamLine("%06d stackClear %x %d", nPgmTime, arg, gNumCones);
		int target = gNumCones == MAX_STACK ? LIFT_TOP : gLiftRaiseTarget[gNumCones];
		liftRaiseSimpleAsync(target, 127, gNumCones < MAX_STACK ? -15 : 0);
		unsigned long liftTimeOut = nPgmTime + 1500;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[liftPoti].value, target, liftTimeOut, TID1(stackClear, 1));

		if (gSensor[armPoti].value < ARM_STACK)
		{
			armRaiseSimpleAsync(ARM_TOP, 127, 0);
			unsigned long armTimeOut = nPgmTime + 1000;
			armTimeoutWhile(armRaiseSimpleState, armTimeOut, TID1(stackClear, 2));
		}

		if (arg & sfMobile)
			mobileSet((tMobileStates)((arg >> 16) & 0xFF), (long)(arg >> 24));

		liftTimeoutWhile(liftRaiseSimpleState, liftTimeOut, TID1(stackClear, 3));

		NEXT_STATE(stackNotRunning)
	}
case stackReturn:
	{
		if (LOGS) writeDebugStreamLine("%06d stackReturn %x %d", nPgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		if (gWall)
			NEXT_STATE(stackWall);

		if (gNumCones <= 3)
		{
			liftSet(liftToTarget, LIFT_RETURN);
			liftTimeOut = nPgmTime + 1300;
			timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[liftPoti].value, LIFT_BOTTOM + 150, liftTimeOut, TID1(stackReturn, 1));
		}

		if (arg & sfLoader)
			armSet(armToBottom, -127);
		else
			armSet(armToTarget, ARM_HORIZONTAL);
		armTimeOut = nPgmTime + 1500;

		if (gNumCones <= 3)
		{

			liftTimeoutWhile(liftToTarget, liftTimeOut, TID1(stackReturn, 2));
		}
		else
		{
			liftSet(liftToTarget, (arg & sfLoader) ? LIFT_LOADER : LIFT_RETURN);
			liftTimeOut = nPgmTime + 1300;
			liftTimeoutWhile(liftToTarget, liftTimeOut, TID1(stackReturn, 4));
		}
		if (LOGS) writeDebugStreamLine("Lift height %d vs %d", gSensor[liftPoti].value, (arg & sfLoader) ? LIFT_LOADER : LIFT_RETURN);

		armTimeoutWhile(armToTarget, armTimeOut, TID1(stackReturn, 6));
		NEXT_STATE(stackNotRunning)
	}
case stackWall:
	{
		if (LOGS) writeDebugStreamLine("%06d stackWall %x %d", nPgmTime, arg, gNumCones);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;

		gWallTurn = wtNone;

		armSet(armToTarget, ARM_PRESTACK - 300);
		liftSet(liftToBottom, -127);
		liftTimeOut = nPgmTime + 1000;
		liftTimeoutWhile(liftToBottom, liftTimeOut, TID1(stackWall, 1));
		armRaiseSimpleAsync(ARM_PRESTACK, 80, 0);
		armTimeOut = nPgmTime + 1000;
		armTimeoutWhile(armRaiseSimpleState, armTimeOut, TID1(stackWall, 2));

		if (LOGS) writeDebugStreamLine("%d gWallTurnCheck false", nPgmTime);
		gWallTurnCheck = true;

		NEXT_STATE(stackNotRunning)
	}
case stackTip:
	{
		if (LOGS) writeDebugStreamLine("%06d stackTip %x", nPgmTime, arg);
		unsigned long armTimeOut;
		unsigned long liftTimeOut;
		unsigned long driveTimeout;

		gDriveManual = false;

		armSet(armToBottom, -127);
		armTimeOut = nPgmTime + 1000;
		//liftLowerSimpleAsync(LIFT_BOTTOM + 200, -127, 0);
		liftSet(liftToTarget, LIFT_BOTTOM + 200);
		liftTimeOut = nPgmTime + 1200;
		liftTimeoutWhile(liftToTarget, liftTimeOut, TID1(stackTip, 1));
		liftSet(liftManaged);
		setLift(-10);
		armTimeoutWhile(armToBottom, armTimeOut, TID1(stackTip, 2));
		setLift(-25);

		moveToTargetDisSimpleAsync(gPosition.a, -7, gPosition.y, gPosition.x, -127, 0, 0, 0, 0, 0, stopNone, mttSimple, true);
		driveTimeout = nPgmTime + 3000;
		autoSimpleTimeoutUntil(autoSimpleNotRunning, driveTimeout, TID1(stackTip, 3));
		liftSet(liftToBottom, -127);
		liftTimeOut = nPgmTime + 1000;
		//sleep(300);
		moveToTargetDisSimpleAsync(gPosition.a, -8, gPosition.y, gPosition.x, -80, 0, 0, 0, 0, 0, stopNone, mttSimple, true);
		driveTimeout = nPgmTime + 3000;
		autoSimpleTimeoutUntil(autoSimpleNotRunning, driveTimeout, TID1(stackTip, 4));
		liftTimeoutWhile(liftToBottom, liftTimeOut, TID1(stackTip, 5));

		NEXT_STATE(stackNotRunning)
	}
})

task failTimeout()
{
	stackSet(stackNotRunning, stackArg & sfNoResetAuto);
	liftReset();
	armReset();
	mobileReset();
	gDriveManual = true;
	if (competitionState == usercontrolState)
		competitionSet(usercontrolState);
	return_t;
}

bool getVelocity(tTimeoutVelSourceType velSourceType, unsigned long velSourceData, float& out)
{
	switch (velSourceType)
	{
	case velSensor:
		velocityCheck(velSourceData);
		if (gSensor[velSourceData].velGood)
		{
			out = gSensor[velSourceData].velocity;
			return true;
		}
		return false;
	case velPtr:
		out = *(float *)velSourceData;
		return true;
	case velLocalY:
		out = gVelocity.x * sin(gPosition.a) + gVelocity.y * cos(gPosition.a);
		return true;
	case velTurn:
		out = gVelocity.a;
		return true;
	default:
		return false;
	}
}

bool TimedOut(unsigned long timeOut, const unsigned char *routine, unsigned short id, bool kill, tTimeoutVelSourceType velSourceType, unsigned long velSourceData, float vel, unsigned long elpsdTime, int* velSafetyCount)
{
	float curVel;

	if (velSafetyCount)
	{
		if ( (elpsdTime > 400 && getVelocity(velSourceType, velSourceData, curVel)) && ( abs(curVel) < abs(vel) || sgn(vel) != sgn(curVel) ) )
			*velSafetyCount++;
		else
			*velSafetyCount = 0;
	}

	if (nPgmTime > timeOut || (velSafetyCount && *velSafetyCount >= 10))
	{
		tHog();
		char description[40];
		if (id >> 8)
			snprintf(description, 40, "%s %d-%d", routine, id >> 8, (word) (id & 0xFF));
		else if (id)
			snprintf(description, 40, "%s %d", routine, (word) id);
		else
			strcpy(description, routine);
		writeDebugStream("%06d EXCEEDED TIME %d, %f - ", nPgmTime, timeOut, curVel);
		if (LOGS) writeDebugStreamLine(description);
		if (kill)
		{
			hogCPU();
			for (tMotor x = port1; x <= port10; ++x)
				gMotor[x].power = motor[x] = 0;
			word p = nCurrentTask, t;
			do {
				t = p;
				p = tEls[t].parent;
			} while (p != -1 && p != nCurrentTask && p != main && (competitionState != usercontrolState || p != _asyncTask_competitionInternal));
			if (t == main)
			{
				stopAllButCurrentTasks();
				startTask(main);
			}
			tStart(failTimeout, true);
			tStopAll(t);
		}
		return true;
	}
	else
	{
		if (DATALOG_TIMEOUT != -1)
		{
			tHog();
			datalogAddValueWithTimeStamp(DATALOG_TIMEOUT, curVel * 1000);
			tRelease();
		}
		return false;
	}
}

bool stackRunning()
{
	return stackState != stackNotRunning;
}

bool cancel()
{
	writeDebugStream("CANCEL");
	bool wasRunning = stackState != stackNotRunning;
	stackSet(stackNotRunning, sfNoResetArm);
	armReset();
	autoSimpleReset();
	gDriveManual = true;
	gStack = false;
	gLoader = false;
	gWall = false;
	gSkillsSpinTimeout = 0;
	return wasRunning;
}

void handleMacros()
{
	if (RISING(BTN_MACRO_STACK) && gNumCones < MAX_STACK)
	{
		gStack = true;
		gLoader = false;
		gWall = false;
	}

	if (RISING(BTN_MACRO_LOADER) && gNumCones < MAX_STACK)
	{
		gStack = true;
		gLoader = true;
		gWall = false;
	}

	if (gStack == true && gNumCones < MAX_STACK)
	{
		if (!stackRunning())
		{
			if (gLoader)
				stackSet(stackPickupLoader, (gNumCones < MAX_STACK - 1) ? (gNumCones >= 4) ? sfStack | sfReturn | sfLoader : sfNone : sfStack | sfDetach);
			else
				stackSet(stackPickupGround, ((gNumCones < MAX_STACK - 1) ? sfStack | sfReturn : sfStack | sfDetach) | (gWall ? sfPull : sfNone));
			gStack = false;
			gLoader = false;
			gWall = false;
		}
	}

	if (RISING(BTN_TURN_LEFT) && gWallTurnCheck)
	{
		gWallTurn = wtLeft;
	}
	else if (RISING(BTN_TURN_RIGHT) && gWallTurnCheck)
	{
		gWallTurn = wtRight;
	}

	if (gSensor[jmpSkills].value)
	{
		if (RISING(BTN_SKILLS_SPIN))
		{
			gDriveManual = true;
			gSkillsSpinTimeout = nPgmTime + 1500;
			turnToAngleNewAlgAsync(gPosition.a + PI, cw, 0.55, 26, 11, false, true, false);
			liftSet(liftToBottom, -127);
		}

		if (RISING(BTN_SKILLS_LIFT) && !stackRunning())
		{
			liftLowerSimpleAsync(LIFT_BOTTOM + 200, -127, 0);
		}
	}
	else
	{
		if (RISING(BTN_GAME_WALL))
		{
			if (stackRunning())
				gWall = true;
			else if (!gSensor[limLift].value || gSensor[armPoti].value < ARM_PRESTACK - 100)
				stackSet(stackWall, sfNone);
			else
			{
				gStack = true;
				gWall = true;
			}
		}

		if (RISING(BTN_GAME_STATIONARY) && !stackRunning())
		{
			if (gNumCones < MAX_STATIONARY)
				stackSet((gSensor[liftPoti].value < gLiftRaiseTargetS[gNumCones] - 150) ? stackStationaryPrep : stackStationary, sfNone);
		}
	}

	if (RISING(BTN_MACRO_PICKUP) && !stackRunning())
	{
		stackSet(stackPickupGround, sfNoResetArm);
	}

	if (RISING(BTN_MACRO_PREP) && !stackRunning())
	{
		liftSet(liftToTarget, LIFT_LOADER);
		armSet(armToBottom, -127);
	}

	if (RISING(BTN_MACRO_CANCEL)) cancel();

	if (RISING(BTN_MACRO_INC) && gNumCones < MAX_STACK && !gWallTurnCheck) {
		++gNumCones;
		if (LOGS) writeDebugStreamLine("%06d CONES %d",nPgmTime,gNumCones);
	}

	if (RISING(BTN_MACRO_DEC) && gNumCones > 0) {
		--gNumCones;
		if (LOGS) writeDebugStreamLine("%06d CONES %d",nPgmTime,gNumCones);
	}

	if (RISING(BTN_MACRO_ZERO))
	{
		gNumCones = 0;
		if (LOGS) writeDebugStreamLine("%06d CONES %d",nPgmTime,gNumCones);
	}

	if (gSkillsSpinTimeout && (autoSimpleState == autoSimpleNotRunning || nPgmTime > gSkillsSpinTimeout || RISING(JOY_THROTTLE) || RISING(JOY_TURN)))
	{
		autoSimpleReset();
		gDriveManual = true;
		gSkillsSpinTimeout = 0;
	}

	if (((RISING(BTN_MACRO_INC) && gJoy[BTN_MACRO_DEC].cur) || (gJoy[BTN_MACRO_INC].cur && RISING(BTN_MACRO_DEC))) && !stackRunning())
	{
		stackSet(stackTip, sfNone);
	}
}

void waitForSkillsOverride(TVexJoysticks joy)
{
	do {
		sleep(10);
		updateJoystick(joy);
	} while (!gJoy[joy].cur);
	usercontrolAsync();
}

NEW_ASYNC_VOID_1(waitForSkillsOverride, TVexJoysticks);

#include "auto.c"
#include "auto_simple.c"
#include "auto_runs.c"
#include "custom_drive.c"
#include "custom_turning.c"
#include "diagnostics.c"


// This function gets called 2 seconds after power on of the cortex and is the first bit of code that is run
void startup()
{
	clearDebugStream();
	if (LOGS) writeDebugStreamLine("Code start");

	// Setup and initilize the necessary libraries
	setupMotors();
	setupSensors();
	setupJoysticks();
	tInit();

	competitionSetup();
	mobileSetup();
	armSetup();
	liftSetup();
	stackSetup();
	autoSimpleSetup();

	setupInvertedSen(jmpSkills);
	setupDgtIn(limLift, 0, 100);
	setupDgtIn(lsBarL, 0, 1500);
	setupDgtIn(lsBarR, 0, 1500);
	setupDgtIn(lsMobile, 0, 2100);
	gSensor[liftPoti].potiCheckVel = true;

	updateTurnLookup();
	updateDriveLookup();

#ifdef MOTOR_SENSOR_LOGS
	gMotor[liftR].datalog = 0;
	gSensor[liftPoti].valueDatalog = 1;
	//gSensor[liftPoti].velDatalog = 2;
	gMotor[arm].datalog = 3;
	gSensor[armPoti].valueDatalog = 4;
	//gSensor[armPoti].velDatalog = 5;
#endif

	velocityClear(liftPoti);
	velocityClear(armPoti);

	gJoy[JOY_TURN].deadzone = DZ_TURN;
	gJoy[JOY_THROTTLE].deadzone = DZ_THROTTLE;
	gJoy[JOY_LIFT_DRIVER].deadzone = DZ_LIFT;
	gJoy[JOY_LIFT_PARTNER].deadzone = DZ_LIFT;
	gJoy[JOY_ARM_DRIVER].deadzone = DZ_ARM;
	gJoy[JOY_ARM_PARTNER].deadzone = DZ_ARM;

	enableJoystick(JOY_TURN);
	enableJoystick(JOY_THROTTLE);
	enableJoystick(JOY_LIFT_DRIVER);
	enableJoystick(JOY_LIFT_PARTNER);
	enableJoystick(JOY_ARM_DRIVER);
	enableJoystick(JOY_ARM_PARTNER);
	enableJoystick(BTN_MOBILE_TOGGLE);
	enableJoystick(BTN_MOBILE_MIDDLE);
	enableJoystick(BTN_MACRO_ZERO);
	enableJoystick(BTN_MACRO_STACK);
	enableJoystick(BTN_MACRO_LOADER);
	enableJoystick(BTN_MACRO_PREP);
	enableJoystick(BTN_GAME_STATIONARY);
	enableJoystick(BTN_GAME_WALL);
	enableJoystick(BTN_MACRO_PICKUP);
	enableJoystick(BTN_MACRO_CANCEL);
	enableJoystick(BTN_MACRO_INC);
	enableJoystick(BTN_MACRO_DEC);
	MIRROR(BTN_MOBILE_TOGGLE);
	MIRROR(BTN_MOBILE_MIDDLE);
	MIRROR(BTN_MACRO_STACK);
	MIRROR(BTN_MACRO_PREP);
	MIRROR(BTN_MACRO_CANCEL);
	MIRROR(BTN_MACRO_INC);
	MIRROR(BTN_MACRO_DEC);
	MIRROR(Btn7L);
	MIRROR(Btn8R);
	mirrorJoystick(BTN_MACRO_ZERO, BTN_MACRO_ZERO_PARTNER);
}

// This function gets called every 25ms during disabled (DO NOT PUT BLOCKING CODE IN HERE)
void disabled()
{
	sCycleData cycle;
	initCycle(cycle, 25, "disabled");
	while (true) {
		updateSensorInputs();
		selectAuto();
		handleLcd();
		endCycle(cycle);
	}
}

// This task gets started at the begining of the autonomous period
void autonomous()
{
	gAutoTime = nPgmTime;
	writeDebugStreamLine("Auto start %d", gAutoTime);

	startSensors();

	stackReset();
	liftReset();
	armReset();
	mobileReset();
	autoSimpleReset();

	tStart(autoMotorSensorUpdateTask);
	tStart(trackPositionTask);

	runAuto();

	writeDebugStreamLine("Auto: %d ms", nPgmTime - gAutoTime);

	setDrive(0, 0);
	stackReset();
	liftReset();
	armReset();
	mobileReset();
	autoSimpleReset();

	return_t;
}

bool gAllowCustomSkills = true;

// This task gets started at the beginning of the usercontrol period
void usercontrol()
{
	startSensors(); // Initilize the sensors
#ifdef TRACK_IN_DRIVER
	initCycle(gMainCycle, 15, "main");
#else
	initCycle(gMainCycle, 10, "main");
#endif

	updateSensorInput(jmpSkills);

#ifdef TRACK_IN_DRIVER
	tStart(trackPositionTask);
#endif

	stackReset();
	liftReset();
	armReset();
	mobileReset();

	gDriveManual = true;
	gMobileCheckLift = true;
	gMobileAutoEnabled = true;
	gStack = false;
	gLoader = false;

	if (!gDriveIgnoreJumper)
	{
		gDriveCurvature = gSensor[jmpSkills].value ? DRIVE_WEIGHT_SKILLS : DRIVE_WEIGHT_GAME;
		updateDriveLookup();
	}

	if (!gTurnIgnoreJumper)
	{
		gTurnCurvature = gSensor[jmpSkills].value ? TURN_WEIGHT_SKILLS : TURN_WEIGHT_GAME;
		updateTurnLookup();
	}

	if (gSensor[jmpSkills].value && gAllowCustomSkills)
	{
		unsigned long driveTimeout;
		unsigned long coneTimeout;

		gAllowCustomSkills = false;

		tStart(autoMotorSensorUpdateTask);
		waitForSkillsOverrideAsync(BTN_MACRO_CANCEL);

		resetPositionFull(gPosition, 47, 14.25, 0);
		resetVelocity(gVelocity, gPosition);

		moveToTargetSimpleAsync(107, 13, 47, 15, 70, 0, 0.5, 6, 55, 14, stopNone, mttProportional, false);
		driveTimeout = nPgmTime + 2000;
		liftRaiseSimpleAsync(gLiftRaiseTarget[1], 127, -20);
		sleep(300);
		mobileSet(mobileBottom, mfNone);
		DRIVE_AWAIT(skills, 1, 1);
		setDrive(55, 55);
		driveTimeout = nPgmTime + 700;
		timeoutWhileFalse((bool *) &gSensor[lsMobile].value, driveTimeout, TID2(skills, 1, 2), false);
		setDrive(-7, -7);
		mobileSet(mobileTop, mfNone);
		coneTimeout = nPgmTime + 2000;
		timeoutWhileLessThanL(VEL_NONE, 0, &gSensor[mobilePoti].value, MOBILE_HALFWAY, coneTimeout, TID2(skills, 1, 3));
		moveToTargetSimpleAsync(119, 12, gPosition.y, gPosition.x, 70, 70, 0.5, 0, 0, 9.5, stopHarsh, mttCascading, false);
		stackSet(stackStack, STACK_RAPID_CONFIG(sfDetach, 3));
		coneTimeout = nPgmTime + 1500;
		stackTimeoutUntil(stackPickupGround, coneTimeout, TID2(skills, 1, 4));
		coneTimeout = nPgmTime + 1500;
		stackTimeoutWhile(stackPickupGround, coneTimeout, TID2(skills, 1, 5));
		coneTimeout = nPgmTime + 1500;
		moveToTargetSimpleAsync(129, 11.5, gPosition.y, gPosition.x, 70, 30, 0.5, 0, 0, 9.5, stopHarsh, mttCascading, false);
		stackTimeoutUntil(stackPickupGround, coneTimeout, TID2(skills, 1, 6));
		coneTimeout = nPgmTime + 1500;
		stackTimeoutWhile(stackPickupGround, coneTimeout, TID2(skills, 1, 7));

		tStop(autoMotorSensorUpdateTask);
		waitForSkillsOverrideKill();
	} else if (gSensor[mobilePoti].value > MOBILE_TOP - 200)
		mobileSet(mobileTop, mfNone);
	else if (gSensor[mobilePoti].value < MOBILE_BOTTOM + 200)
		mobileSet(mobileBottom, mfNone);

	while (true)
	{
		updateSensorInputs();
		updateJoysticks();

		selectAuto();

		handleDrive();
		handleLift();
		handleArm();
		handleMobile();
		handleMacros();

		handleLcd();

		if (gSensor[jmpSkills].value != gSensor[jmpSkills].lstValue)
		{
			if (!gDriveIgnoreJumper)
			{
				gDriveCurvature = gSensor[jmpSkills].value ? DRIVE_WEIGHT_SKILLS : DRIVE_WEIGHT_GAME;
				updateDriveLookup();
			}

			if (!gTurnIgnoreJumper)
			{
				gTurnCurvature = gSensor[jmpSkills].value ? TURN_WEIGHT_SKILLS : TURN_WEIGHT_GAME;
				updateTurnLookup();
			}
		}

		updateSensorOutputs();
		updateMotors();
		endCycle(gMainCycle);
	}

	return_t;
}
